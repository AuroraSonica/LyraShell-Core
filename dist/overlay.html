<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lyra Gaming Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: #fff;
            height: 100vh;
            overflow: hidden;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .overlay-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 15px;
        }

        .overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 15px;
        }

        .overlay-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #4a9eff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            font-size: 0.9em;
            color: #aaa;
        }

        .window-controls {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .control-btn.close:hover {
            background: rgba(255, 107, 107, 0.8);
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
            margin-bottom: 15px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        .messages-container::-webkit-scrollbar {
            width: 6px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .message {
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
            animation: fadeIn 0.3s ease;
        }

        .message.user {
            background: rgba(74, 158, 255, 0.2);
            border-left: 3px solid #4a9eff;
            margin-left: 20px;
        }

        .message.lyra {
            background: rgba(255, 107, 53, 0.2);
            border-left: 3px solid #ff6b35;
            margin-right: 20px;
        }

        .message-header {
            font-size: 0.8em;
            color: #aaa;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .message-content {
            font-size: 0.9em;
            line-height: 1.4;
        }

        .mood-indicator {
            font-size: 0.8em;
            color: #ff6b35;
            font-style: italic;
        }

        .input-area {
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 0.9em;
            outline: none;
            padding: 8px 0;
        }

        .message-input::placeholder {
            color: #888;
        }

        .send-btn {
            background: linear-gradient(135deg, #4a9eff, #0066cc);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .send-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.3);
        }

        .send-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .visual-status {
            font-size: 0.8em;
            color: #aaa;
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .status-active {
            color: #4CAF50;
        }

        .status-gaming {
            color: #ff6b35;
        }

        .status-youtube {
            color: #ff0000;
        }

        .no-messages {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 20px 0;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loading {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #aaa;
            font-style: italic;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }
		
		.gaming-toggle input:checked + .toggle-slider {
			background: linear-gradient(135deg, #ff6b35, #ff9558);
		}

		.toggle-slider::after {
			content: '';
			position: absolute;
			top: 3px;
			left: 3px;
			width: 20px;
			height: 20px;
			background: #fff;
			border-radius: 50%;
			transition: all 0.3s ease;
		}

		.gaming-toggle input:checked + .toggle-slider::after {
			transform: translateX(24px);
		}

        /* Draggable area */
        .overlay-header {
            -webkit-app-region: drag;
        }

        .window-controls {
            -webkit-app-region: no-drag;
        }
    </style>
</head>
<body>
    <div class="overlay-container">
        <div class="overlay-header">
            <div class="overlay-title">
                üéÆ Lyra
                <span id="statusIndicator" class="status-indicator">Ready</span>
            </div>
            <div class="window-controls">
                <button id="closeBtn" class="control-btn close">‚úñÔ∏è</button>
            </div>
        </div>

        <div id="visualStatus" class="visual-status">
            Loading visual status...
        </div>

        <div class="chat-area">
            <div id="messagesContainer" class="messages-container">
                <div class="no-messages">
                    Start chatting with Lyra while gaming!<br>
                    <small>She can see what you're playing and comment naturally.</small>
                </div>
            </div>

            <div class="input-area">
                <input 
                    type="text" 
                    id="messageInput" 
                    class="message-input" 
                    placeholder="Message Lyra..."
                    maxlength="500"
                >
                <button id="sendBtn" class="send-btn">Send</button>
            </div>
			<!-- Voice Mode Toggle -->
			<div class="voice-mode-section" style="margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
				<button id="voiceToggleBtn" class="voice-toggle-btn" style="
					background: linear-gradient(135deg, #ff6b35, #ff4500);
					border: none;
					color: white;
					padding: 8px 16px;
					border-radius: 6px;
					cursor: pointer;
					font-weight: bold;
					width: 100%;
					transition: all 0.2s ease;
				">
					üé§ Voice Mode
				</button>
				
				<div id="voiceStatus" class="voice-status" style="
					display: none;
					margin-top: 10px;
					text-align: center;
					color: #ff6b35;
					font-size: 0.9em;
				">
					<span id="voiceStateIcon">üé§</span>
					<span id="voiceStateText">Ready</span>
				</div>
			</div>
			
			<!-- TTS Toggle -->
		<div class="tts-toggle-section" style="margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
			<label class="gaming-toggle" style="display: flex; align-items: center; gap: 15px; cursor: pointer;">
				<input type="checkbox" id="overlayTtsToggle" style="display: none;">
				<span class="toggle-slider" style="
					position: relative;
					width: 50px;
					height: 26px;
					background: rgba(255, 255, 255, 0.1);
					border-radius: 13px;
					transition: all 0.3s ease;
				"></span>
				<span class="toggle-label">
					<strong>üîä Text-to-Speech</strong>
					<small style="display: block; color: #888;">Speak Lyra's responses</small>
				</span>
			</label>
		</div>
		<!-- Add this after the TTS toggle section -->
		<div class="overlay-help" style="
			margin-top: 10px;
			padding: 10px;
			background: rgba(255, 255, 255, 0.05);
			border-radius: 8px;
			font-size: 0.85em;
			color: #888;
		">
			<div>üéÆ <strong>Controls:</strong></div>
			<div>‚Ä¢ Hold <kbd>Ctrl</kbd> for push-to-talk</div>
			<div>‚Ä¢ Type "esc" in Minecraft chat to release mouse</div>
			<div>‚Ä¢ Click outside to return to game</div>
		</div>
		<!-- Autonomous Actions Toggle (Collapsible) -->
<div class="autonomous-toggle-section" style="margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
    <div class="autonomous-header" style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" 
         onclick="toggleAutonomousPanel()">
        <span style="font-weight: bold; color: #ff6b35;">ü§ñ Autonomous Actions</span>
        <span id="autonomousIndicator" style="font-size: 0.8em; color: #888;">Disabled</span>
        <span id="autonomousChevron" style="color: #ff6b35;">‚ñº</span>
    </div>
    
    <div id="autonomousPanel" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        <label class="gaming-toggle" style="display: flex; align-items: center; gap: 15px; cursor: pointer;">
            <input type="checkbox" id="overlayAutonomousToggle" style="display: none;">
            <span class="toggle-slider" style="
                position: relative;
                width: 50px;
                height: 26px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 13px;
                transition: all 0.3s ease;
            "></span>
            <span>Enable</span>
        </label>
        
        <div style="margin-top: 10px; font-size: 0.85em;">
            <div style="margin-bottom: 5px;">
                <span style="color: #888;">Interval:</span>
                <input type="range" id="overlayAutonomousInterval" min="20" max="120" value="30" 
                       style="width: 100px; vertical-align: middle;">
                <span id="overlayIntervalDisplay" style="color: #ff6b35;">30s</span>
            </div>
            
            <label style="display: flex; align-items: center; gap: 5px; font-size: 0.85em;">
                <input type="checkbox" id="overlayAutonomousRandom">
                <span>Random timing</span>
            </label>
        </div>
        
        <div style="margin-top: 8px; font-size: 0.8em; color: #ff6b35;">
            Next action: <span id="overlayAutonomousCountdown">--</span>
        </div>
    </div>
</div>

		

			<script>
			
const { invoke } = window.__TAURI__.core;
const { appWindow } = window.__TAURI__.window;

    console.log('üé§ Overlay script starting...');
    console.log('üé§ Tauri available:', !!window.__TAURI__);
    console.log('üé§ Event system:', !!window.__TAURI__.event);
	
	    // Test event system immediately
    window.__TAURI__.event.listen('test-event', (e) => {
        console.log('üé§ Test event received:', e);
    });
// Debug: Log all Tauri events
window.__TAURI__.event.listen('global_ptt_start', (event) => {
    console.log('üé§ OVERLAY: Global PTT start received!', event);
});

window.__TAURI__.event.listen('global_ptt_stop', (event) => {
    console.log('üé§ OVERLAY: Global PTT stop received!', event);
});	


// Autonomous panel toggle
function toggleAutonomousPanel() {
    const panel = document.getElementById('autonomousPanel');
    const chevron = document.getElementById('autonomousChevron');
    
    if (panel.style.display === 'none') {
        panel.style.display = 'block';
        chevron.textContent = '‚ñ≤';
    } else {
        panel.style.display = 'none';
        chevron.textContent = '‚ñº';
    }
}

// Autonomous controls
document.getElementById('overlayAutonomousToggle').addEventListener('change', async (e) => {
    const indicator = document.getElementById('autonomousIndicator');
    
    if (e.target.checked) {
        const interval = document.getElementById('overlayAutonomousInterval').value;
        const randomVariance = document.getElementById('overlayAutonomousRandom').checked;
        
        await invoke('enable_autonomous_actions', {
            interval: parseInt(interval),
            randomVariance: randomVariance
        });
        
        indicator.textContent = 'Active';
        indicator.style.color = '#4CAF50';
    } else {
        await invoke('disable_autonomous_actions');
        indicator.textContent = 'Disabled';
        indicator.style.color = '#888';
    }
});

document.getElementById('overlayAutonomousInterval').addEventListener('input', (e) => {
    document.getElementById('overlayIntervalDisplay').textContent = `${e.value}s`;
});

// Update countdown
setInterval(async () => {
    const toggle = document.getElementById('overlayAutonomousToggle');
    if (toggle && toggle.checked) {
        try {
            const status = await invoke('get_autonomous_status');
            if (status.nextActionIn) {
                document.getElementById('overlayAutonomousCountdown').textContent = 
                    `${Math.round(status.nextActionIn)}s`;
            }
        } catch (err) {
            // Ignore errors when overlay is hidden
        }
    }
}, 1000);	
			

    
    class OverlayChat {
        constructor() {
            this.isLoading = false;
            this.messageHistory = [];
            this.setupEventListeners();
            this.loadInitialData();
            this.startStatusPolling();
            this.initializeTTS();
			this.setupPushToTalk()
            
            // TTS setup
            const ttsToggle = document.getElementById('overlayTtsToggle');
            if (ttsToggle) {
                // Load saved preference
                window.ttsEnabled = localStorage.getItem('overlayTts') === 'true';
                ttsToggle.checked = window.ttsEnabled;
                
                ttsToggle.addEventListener('change', (e) => {
                    window.ttsEnabled = e.target.checked;
                    localStorage.setItem('overlayTts', e.target.checked);
                });
            }
            
            // Setup push-to-talk
            // Delay PTT setup to ensure window is ready
			setTimeout(() => this.setupPushToTalk(), 100);
            
            // Listen for chat history updates when window is reused
            if (window.__TAURI__) {
                window.__TAURI__.event.listen('reload_chat_history', (event) => {
                    console.log('Reloading chat history...');
                    // Clear existing messages
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.innerHTML = '';
                    
                    // Load new history
                    const history = event.payload;
                    if (history && history.length > 0) {
                        history.forEach(msg => {
                            this.addMessage(
                                msg.sender || 'user',
                                msg.content || msg.message || '',
                                null,
                                false
                            );
                        });
                        this.scrollToBottom();
                    } else {
                        // Show empty state
                        messagesContainer.innerHTML = `
                            <div class="no-messages">
                                <span class="empty-icon">üéÆ</span>
                                <p>Start chatting with Lyra while gaming!</p>
                                <small>She can see what you're playing and comment naturally.</small>
                            </div>
                        `;
                    }
                });
            }
        }
        
        async initializeTTS() {
            try {
                // Get voice config from backend
                const result = await invoke('get_voice_config');
                if (result && result.length >= 2) {
                    window.elevenLabsApiKey = result[0];
                    window.lyraVoiceId = result[1];
                    console.log('üîä Overlay TTS: Loaded voice config');
                    console.log('üîä Voice ID:', window.lyraVoiceId);
                    console.log('üîä API Key present:', !!window.elevenLabsApiKey);
                }
            } catch (error) {
                console.error('Failed to load voice config:', error);
            }
        }

        async loadInitialData() {
            // Load chat history
            await this.loadChatHistory();
            // Load visual status
            await this.loadVisualStatus();
        }

        async loadChatHistory() {
            try {
                console.log('Loading chat history...');
                const history = await invoke('get_overlay_chat_history');
                console.log('Loaded chat history:', history);
                console.log('History length:', history ? history.length : 0);
                
                if (history && history.length > 0) {
                    // Clear the "no messages" placeholder
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.innerHTML = '';
                    
                    // Add each historical message
                    history.forEach(msg => {
                        this.addMessage(
                            msg.sender || 'user',
                            msg.content || msg.message || '',
                            null,
                            false // Don't animate historical messages
                        );
                    });
                    
                    this.scrollToBottom();
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
            }
        }
        
        setupPushToTalk() {
		// Create visual indicator if it doesn't exist
		if (!document.getElementById('pttIndicator')) {
			const pttIndicator = document.createElement('div');
			pttIndicator.id = 'pttIndicator';
			pttIndicator.style.cssText = `
				position: fixed;
				top: 10px;
				right: 10px;
				padding: 8px 16px;
				background: rgba(255, 0, 0, 0.8);
				color: white;
				border-radius: 20px;
				font-weight: bold;
				display: none;
				z-index: 1000;
				animation: pulse 1s infinite;
			`;
			pttIndicator.textContent = 'üé§ Recording...';
			document.body.appendChild(pttIndicator);
			
			// Add animation style if not exists
			if (!document.getElementById('ptt-pulse-style')) {
				const style = document.createElement('style');
				style.id = 'ptt-pulse-style';
				style.textContent = `
					@keyframes pulse {
						0% { opacity: 0.8; }
						50% { opacity: 1; }
						100% { opacity: 0.8; }
					}
				`;
				document.head.appendChild(style);
			}
		}
		
		// Start the global PTT listener
		invoke('start_global_ptt_listener').then(result => {
			console.log('üé§ Global PTT:', result);
			if (this.logActivity) {
            this.logActivity('üé§ Push-to-talk ready (Ctrl or F4)');
        }
		}).catch(err => {
			console.error('Failed to start PTT listener:', err);
		});
	}

        // Add this method to handle voice messages
        async sendVoiceMessage(text) {
            // Reuse the sendMessage logic but with voice input
            const messageInput = document.getElementById('messageInput');
            messageInput.value = text;
            await this.sendMessage();
        }

        setupEventListeners() {
            // Window controls
            const closeBtn = document.getElementById('closeBtn');
            if (closeBtn) {
                console.log('Setting up close button handler');
                closeBtn.addEventListener('click', async () => {
                    console.log('Close button clicked');
                    try {
                        // Just hide the overlay instead of closing it
						// Emit event to refresh main chat
					await window.__TAURI__.event.emit('refresh_chat_from_overlay', {});
                        await invoke('hide_overlay_window');
                    } catch (error) {
                        console.error('Failed to hide overlay:', error);
                        // Fallback - try to hide via window API
                        try {
                            await window.__TAURI__.window.getCurrent().hide();
                        } catch (e) {
                            console.error('Fallback hide also failed:', e);
                        }
                    }
                });
            } else {
                console.error('Close button not found!');
            }

            // Message input
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');

            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });

            sendBtn.addEventListener('click', () => {
                this.sendMessage();
            });

            // Auto-resize on window resize
            window.addEventListener('resize', () => {
                this.scrollToBottom();
            });
            
            // ESC key to close overlay
            document.addEventListener('keydown', async (e) => {
                if (e.key === 'Escape') {
                    console.log('ESC pressed, closing overlay');
                    try {
                        await invoke('hide_overlay_window');
                    } catch (error) {
                        console.error('Failed to hide overlay via ESC:', error);
                        // Fallback
                        try {
                            await window.__TAURI__.window.getCurrent().hide();
                        } catch (e2) {
                            console.error('Fallback hide also failed:', e2);
                        }
                    }
                }
            });

            // Voice mode button
            const voiceToggleBtn = document.getElementById('voiceToggleBtn');
            if (voiceToggleBtn) {
                voiceToggleBtn.addEventListener('click', () => {
                    this.toggleVoiceMode();
                });
            }
        }

        async loadVisualStatus() {
            try {
                const status = await invoke('get_overlay_visual_status');
                this.updateVisualStatus(status);
            } catch (error) {
                console.error('Failed to load visual status:', error);
                this.updateVisualStatus('‚ùå Status unavailable');
            }
        }

        updateVisualStatus(status) {
            const statusElement = document.getElementById('visualStatus');
            if (!statusElement) return;
            
            statusElement.textContent = status;

            // Update status indicator
            const indicator = document.getElementById('statusIndicator');
            if (!indicator) return;
            
            if (status.includes('Gaming mode') || status.includes('active')) {
                statusElement.className = 'visual-status status-gaming';
                indicator.textContent = 'Active';
                indicator.style.color = '#00ff88';
            } else if (status.includes('disabled')) {
                statusElement.className = 'visual-status';
                indicator.textContent = 'Disabled';
                indicator.style.color = '#666';
            } else {
                statusElement.className = 'visual-status status-active';
                indicator.textContent = 'Ready';
                indicator.style.color = '#4a9eff';
            }
        }

        async sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message || this.isLoading) return;

            // Clear input and show loading
            messageInput.value = '';
            this.isLoading = true;
            this.updateSendButton();

            // Add user message to chat
            this.addMessage('user', message);

            // Show loading indicator
            const loadingId = this.addLoadingMessage();

            try {
                // Check gaming status first
                const gamingStatus = await invoke('get_gaming_status');
                console.log('üéÆ Gaming status:', gamingStatus);

                if (!gamingStatus.includes('enabled')) {
                    console.warn('‚ö†Ô∏è Watch mode is not enabled!');
                    this.removeLoadingMessage(loadingId);
                    this.addMessage('system', '‚ö†Ô∏è Watch mode is not enabled - enable it in the Gaming tab first!');
                    return;
                }

                // First, capture fresh game context
                let gameContext = null;
                try {
                    console.log('üì∏ Attempting to capture game context...');
                    const captureResult = await invoke('capture_game_context_on_demand');
                    console.log('üì∏ Capture result:', captureResult);
                    
                    if (captureResult) {
                        gameContext = captureResult;
                        console.log('üì∏ Fresh game context captured:', gameContext.game_title);
                    } else {
                        console.log('üì∏ No game context returned');
                    }
                } catch (captureError) {
                    console.warn('Failed to capture game context:', captureError);
                    // Continue without game context
                }

                console.log('üì§ Sending to ask_lyra_gaming_fast with context:', gameContext ? 'YES' : 'NO');

                // Send message to Lyra with fresh gaming context
                const response = await invoke('ask_lyra_gaming_fast', { 
                    message: message,
                    gameContext: gameContext
                });

                console.log('üì• Response from Lyra:', response);

                // Remove loading and add Lyra's response
                this.removeLoadingMessage(loadingId);
                
                // Handle response properly
                let responseText = '';
                if (typeof response === 'string') {
                    responseText = response;
                } else if (response && response.output) {
                    responseText = response.output;
                } else if (response && response.message) {
                    responseText = response.message;
                } else {
                    console.error('Unexpected response format:', response);
                    responseText = 'Error: Unexpected response format';
                }

                this.addMessage('lyra', responseText);

                // TTS if enabled
                if (window.ttsEnabled && responseText) {
                    try {
                        // Use the same speakText function from the main app
                        if (typeof speakText === 'function') {
                            await speakText(responseText);
                        } else {
                            // If speakText isn't available, use the inline version
                            console.log('üîä Overlay TTS: Speaking with Eleven Labs');
                            
                            // Make sure we have credentials
                            if (!window.elevenLabsApiKey || !window.lyraVoiceId) {
                                console.error('üîä TTS: No credentials, falling back to browser');
                                const utterance = new SpeechSynthesisUtterance(responseText);
                                speechSynthesis.speak(utterance);
                                return;
                            }
                            
                            // Clean the text
                            const cleanText = responseText
                                .replace(/\*[^*]+\*/g, '') // Remove *actions*
                                .replace(/^\s*\[[^\]]+\]\s*/g, '') // Remove [COMMANDS]
                                .replace(/üåÖ|üò¥|ü•±|üí§|‚ú®|üî•|üí≠|üé®|üí´|üåô|üéµ|üé§/g, '') // Remove emojis
                                .trim();
                            
                            // Call Eleven Labs directly
                            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${window.lyraVoiceId}`, {
                                method: 'POST',
                                headers: {
                                    'xi-api-key': window.elevenLabsApiKey,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    text: cleanText,
                                    model_id: "eleven_flash_v2_5",
                                    voice_settings: {
                                        stability: 0.5,
                                        similarity_boost: 0.75,
                                        style: 0.5,
                                        use_speaker_boost: true
                                    }
                                })
                            });
                            
                            if (response.ok) {
                                const audioBlob = await response.blob();
                                const audioUrl = URL.createObjectURL(audioBlob);
                                const audio = new Audio(audioUrl);
                                audio.volume = 0.7; // Default volume
                                
                                audio.onended = () => {
                                    URL.revokeObjectURL(audioUrl);
                                    console.log('üîä Overlay TTS: Playback complete');
                                };
                                
                                await audio.play();
                            } else {
                                throw new Error('Eleven Labs API failed');
                            }
                        }
                    } catch (e) {
                        console.error('üîä TTS failed, using browser fallback:', e);
                        const utterance = new SpeechSynthesisUtterance(responseText);
                        speechSynthesis.speak(utterance);
                    }
                }

            } catch (error) {
                console.error('Error sending message:', error);
                this.removeLoadingMessage(loadingId);
                this.addMessage('system', `Error: ${error}`);
            } finally {
                this.isLoading = false;
                this.updateSendButton();
                messageInput.focus();
            }
        }

        addMessage(type, content, mood = null, animate = true) {
            const messagesContainer = document.getElementById('messagesContainer');
            
            // Remove "no messages" placeholder if it exists
            const noMessages = messagesContainer.querySelector('.no-messages');
            if (noMessages) {
                noMessages.remove();
            }

            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}`;
            if (animate) {
                messageElement.style.animation = 'fadeIn 0.3s ease';
            }

            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit' 
            });

            let header = '';
            if (type === 'user') {
                header = `<div class="message-header">You <span>${timestamp}</span></div>`;
            } else if (type === 'lyra') {
                const moodDisplay = mood ? `<span class="mood-indicator">${mood}</span>` : '';
                header = `<div class="message-header">Lyra ${moodDisplay} <span>${timestamp}</span></div>`;
            } else {
                header = `<div class="message-header">System <span>${timestamp}</span></div>`;
            }

            messageElement.innerHTML = `
                ${header}
                <div class="message-content">${this.escapeHtml(content)}</div>
            `;

            messagesContainer.appendChild(messageElement);
            this.scrollToBottom();

            // Store in history
            this.messageHistory.push({ type, content, timestamp, mood });

            // Keep only last 50 messages
            if (this.messageHistory.length > 50) {
                this.messageHistory.shift();
                const firstMessage = messagesContainer.querySelector('.message');
                if (firstMessage) {
                    firstMessage.remove();
                }
            }
        }

        addLoadingMessage() {
            const messagesContainer = document.getElementById('messagesContainer');
            const loadingElement = document.createElement('div');
            const loadingId = 'loading_' + Date.now();
            
            loadingElement.id = loadingId;
            loadingElement.className = 'message lyra';
            loadingElement.innerHTML = `
                <div class="message-header">Lyra <span>${new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' })}</span></div>
                <div class="message-content loading">Thinking</div>
            `;

            messagesContainer.appendChild(loadingElement);
            this.scrollToBottom();
            return loadingId;
        }

        removeLoadingMessage(loadingId) {
            const loadingElement = document.getElementById(loadingId);
            if (loadingElement) {
                loadingElement.remove();
            }
        }

        updateSendButton() {
            const sendBtn = document.getElementById('sendBtn');
            if (!sendBtn) return;
            
            sendBtn.disabled = this.isLoading;
            sendBtn.textContent = this.isLoading ? 'Sending...' : 'Send';
        }

        scrollToBottom() {
            const messagesContainer = document.getElementById('messagesContainer');
            if (messagesContainer) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        toggleVoiceMode() {
            // Voice mode implementation
            console.log('Voice mode toggled');
            // Add your voice mode logic here
        }

        startStatusPolling() {
            // Update visual status every 30 seconds
            setInterval(() => {
                this.loadVisualStatus();
            }, 30000);
        }
    }
	
	window.startPTTRecording = function() {
    console.log('üé§ Starting PTT recording...');
    
    // Reset transcripts
    window.pttTranscript = '';
    window.pttFinalResults = [];
    
    if ('webkitSpeechRecognition' in window && !window.pttRecognition) {
        window.pttRecognition = new webkitSpeechRecognition();
        window.pttRecognition.continuous = true;
        window.pttRecognition.interimResults = true;
        window.pttRecognition.lang = 'en-US';
        
        window.pttRecognition.onstart = () => {
            const indicator = document.getElementById('pttIndicator');
            if (indicator) indicator.style.display = 'block';
            console.log('üé§ PTT: Recording started');
        };
        
        window.pttRecognition.onresult = (event) => {
            // Accumulate ALL results, not just new ones
            let fullTranscript = '';
            let currentInterim = '';
            
            // Go through ALL results from the beginning
            for (let i = 0; i < event.results.length; i++) {
                const result = event.results[i];
                const transcript = result[0].transcript;
                
                if (result.isFinal) {
                    // Store final results by index to avoid duplicates
                    window.pttFinalResults[i] = transcript;
                } else {
                    currentInterim = transcript;
                }
            }
            
            // Build complete transcript from all final results plus current interim
            fullTranscript = window.pttFinalResults.filter(t => t).join(' ');
            if (currentInterim) {
                fullTranscript += ' ' + currentInterim;
            }
            
            // Update visual feedback
            const indicator = document.getElementById('pttIndicator');
            if (indicator) {
                indicator.textContent = `üé§ Recording: "${fullTranscript}"`;
            }
            
            console.log('üé§ PTT Full transcript:', fullTranscript);
            window.pttTranscript = fullTranscript;
        };
        
        window.pttRecognition.onerror = (event) => {
            console.error('PTT Error:', event.error);
            const indicator = document.getElementById('pttIndicator');
            if (indicator) indicator.style.display = 'none';
            window.pttRecognition = null;
        };
        
        window.pttRecognition.onend = () => {
            const indicator = document.getElementById('pttIndicator');
            if (indicator) indicator.style.display = 'none';
            console.log('üé§ PTT: Recording ended');
            window.pttRecognition = null;
        };
        
        try {
            window.pttRecognition.start();
        } catch (e) {
            console.error('Failed to start PTT:', e);
            window.pttRecognition = null;
        }
    }
};

	window.stopPTTRecording = function() {
		console.log('üé§ Stopping PTT recording...');
		if (window.pttRecognition) {
			window.pttRecognition.stop();
			
			// Send the complete message when button is released
			if (window.pttTranscript && window.pttTranscript.trim()) {
				console.log('üé§ Sending complete message:', window.pttTranscript);
				if (window.overlayChat) {
					window.overlayChat.sendVoiceMessage(window.pttTranscript.trim());
				}
			}
			
			// Reset
			window.pttTranscript = '';
		}
	};

	// Global PTT state
	window.isRecording = false;

	// Set up global PTT listeners immediately
	window.__TAURI__.event.listen('global_ptt_start', (event) => {
		console.log('üé§ Global PTT start event:', event.payload);
		if (!window.isRecording && !window.voiceMode) {
			window.isRecording = true;
			window.startPTTRecording();
		}
	});

	window.__TAURI__.event.listen('global_ptt_stop', (event) => {
		console.log('üé§ Global PTT stop event:', event.payload);
		if (window.isRecording) {
			window.isRecording = false;
			window.stopPTTRecording();
		}
	});

    // Initialize overlay when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        window.overlayChat = new OverlayChat();
    });
	
		window.__TAURI__.event.listen('autonomous_action_trigger', async (event) => {
		const { prompt, gameContext } = event.payload;
		
		// Call through the normal gaming flow which includes full modular prompt
		const response = await invoke('ask_lyra_gaming_fast', {
			message: prompt,
			gameContext: gameContext
		});
		
		console.log('ü§ñ Autonomous action completed:', response);
	});
	
	// Listen for autonomous action triggers
	window.__TAURI__.event.listen('trigger_autonomous_action', async (event) => {
		const { prompt, gameContext } = event.payload;
		
		console.log('ü§ñ Autonomous action triggered');
		
		// Add system message first
		if (window.overlayChat) {
			window.overlayChat.addMessage('system', 'ü§ñ [Autonomous Action]');
		}
		
		// Send through normal gaming flow
		try {
			const response = await invoke('ask_lyra_gaming_fast', {
				message: prompt,
				gameContext: gameContext
			});
			
			// Response will appear through normal message flow
			console.log('ü§ñ Autonomous action completed');
		} catch (error) {
			console.error('Autonomous action failed:', error);
		}
	});

    // Listen for visual capture events
    if (window.__TAURI__) {
        window.__TAURI__.event.listen('visual_capture', (event) => {
            if (window.overlayChat) {
                window.overlayChat.loadVisualStatus();
            }
        });

        // Listen for game context updates
        window.__TAURI__.event.listen('game_context_captured', (event) => {
            console.log('Game context received:', event.payload);
            // Could display game info in the overlay
        });
    }
</script>
</body>
</html>